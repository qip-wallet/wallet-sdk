import*as t from"bitcore-mnemonic";import{initEccLib as e,payments as r,Psbt as a,networks as s,crypto as n}from"bitcoinjs-lib";import*as i from"tiny-secp256k1";import{ECPairFactory as o}from"ecpair";import c from"@mempool/mempool.js";import{bech32m as u,bech32 as d}from"bech32";e(i);const p=o(i);class h{constructor(){var e=this;this.createPassPhrase=()=>{try{return{passPhrase:new t(t.Words.ENGLISH).toString()}}catch(t){throw new Error(t.message)}},this.accountKeys=e=>{try{const r=this.getNetwork(e.networkName);let a=new t(e.passPhrase).toHDPrivateKey(e.passPhrase).derive(`m/44/0/0/0/${e.path}`).privateKey.toString(),s=p.fromPrivateKey(Buffer.from(a.slice(0,32)),{network:r});return{privateKey:s.privateKey.toString(),wif:s.toWIF()}}catch(t){throw new Error(t.message)}},this.createAddress=t=>{var e,a,s;try{const n=this.getNetwork(t.networkName);let i,o,c;switch(t.privateKey?i=p.fromPrivateKey(Buffer.from(t.privateKey),{network:n}):t.wif&&(i=p.fromWIF(t.wif,n)),t.addressType){case"taproot":const t=this.tweakSigner(i,{network:n}),u=r.p2tr({pubkey:this.toXOnly(t.publicKey),network:n});o=null!=(e=u.address)?e:"",c=u.output;break;case"legacy":const d=r.p2pkh({pubkey:i.publicKey,network:n});o=null!=(a=d.address)?a:"",c=d.output;break;case"segwit":const p=r.p2wpkh({pubkey:i.publicKey,network:n});o=null!=(s=p.address)?s:"",c=p.output}return{address:o,script:c}}catch(t){console.log(t)}},this.init=async function(t){const{bitcoin:{addresses:e,fees:r,transactions:a}}=c({hostname:"mempool.space",network:t});return{addresses:e,fees:r,transactions:a}},this.getAddressType=({address:t,networkName:e})=>{try{let r;switch(e){case"mainnet":r=this.mainnetAddressType(t,e);break;case"testnet":r=this.testnetAddressType(t)}return null==r?`invalid ${e} address`:r}catch(t){throw new Error(t.message)}},this.getUtxo=async function({networkName:t,address:r}){try{const{addresses:a}=await e.init(t);return(await a.getAddressTxsUtxo({address:r})).map(t=>({txid:t.txid,vout:t.vout,value:t.value}))}catch(t){throw new Error(t.message)}},this.getFeeRate=async function(t){try{let{fees:r}=await e.init(t);return await r.getFeesRecommended()}catch(t){throw new Error(t.message)}},this.getTransactionDetails=async function({txid:t,networkName:r}){try{let{transactions:a}=await e.init(r);return await a.getTx({txid:t})}catch(t){throw new Error(t.message)}},this.createTransaction=async function({input:t,output:r,addressType:a,networkName:s,feeRate:n,privateKey:i,wif:o}){try{let c,u=await e.getInputData(a,t,s,i,o),d=r,p=0,h=0,w=new Map,y=[];if(i){c=e.createAddress({addressType:a,networkName:s,privateKey:i}).address;let t=e.getAddressType({address:c,networkName:s});w.set(t,1)}else if(i){c=e.createAddress({addressType:a,networkName:s,wif:o}).address;let t=e.getAddressType({address:c,networkName:s});w.set(t,1)}t.forEach(t=>{p+=t.value}),r.forEach(t=>{let r=e.getAddressType({address:t.address,networkName:s});h+=t.value,w.has(r)?w.set(r,w.get(r)+1):w.set(r,1)}),w.forEach((t,e)=>{y.push({outputType:e,count:t})});let f=e.getTransactionSize({input:t.length,output:y,addressType:a}),l=f.txBytes*n;if(console.log(l),p-l-h<=550)return new Error("not enough sats in input for transaction");d.push({address:c,value:p-h-l});let m=e.signTransaction({input:u,output:d,addressType:a,networkName:s,privateKey:i});return console.log(m),{input:u,output:d,transactionFee:l,transactionSize:f,totalSpent:h+l}}catch(t){throw new Error(t.message)}},this.signTransaction=t=>{try{const e=this.getNetwork(t.networkName);let r;t.privateKey?r=p.fromPrivateKey(Buffer.from(t.privateKey),{network:e}):t.wif&&(r=p.fromWIF(t.wif,e)),"taproot"===t.addressType&&(r=this.tweakSigner(r,e));const s=new a({network:e}).addInputs(t.input).addOutputs(t.output).signAllInputs(r).finalizeAllInputs().extractTransaction();return{txHex:s.toHex(),signedTransaction:s}}catch(t){throw new Error(t.message)}},this.createSingleTransaction=async function({receiver:t,amount:r,addressType:a,networkName:s,feeRate:n,privateKey:i,wif:o}){try{let c,u=[],d=[],p=0,h=new Map,w=[];if(d.push({address:t,value:r}),i){c=e.createAddress({addressType:a,networkName:s,privateKey:i}).address;let t=e.getAddressType({address:c,networkName:s});h.set(t,1)}else if(o){c=e.createAddress({addressType:a,networkName:s,wif:o}).address;let t=e.getAddressType({address:c,networkName:s});h.set(t,1)}h.forEach((t,e)=>{w.push({outputType:e,count:t})});let y,f=await e.getUtxo({networkName:s,address:c});for(let t=0;t<f.length;t++){let s=0;if(u.length>0&&(s=u.length),p+=f[t].value,!(p-e.getTransactionSize({input:s,output:w,addressType:a}).txBytes*n-r<550)){u.push({txid:f[t].txid,vout:f[t].vout,value:f[t].value});break}u.push({txid:f[t].txid,vout:f[t].vout,value:f[t].value})}if(p<e.getTransactionSize({input:u.length,output:w,addressType:a}).txBytes*n+r+550)throw new Error("available balance is not sufficient for transaction");return(i||o)&&(y=await e.createTransaction({input:u,output:d,addressType:a,networkName:s,feeRate:n,privateKey:i})),y}catch(t){throw new Error(t.message)}},this.getInputData=async function(t,r,a,s,n){try{let i,o,{transactions:c}=await e.init(a),u=e.getNetwork(a),d=await Promise.all(r.map(async function(t){return{tx:await c.getTx({txid:t.txid}),vout:t.vout}}));switch(t){case"legacy":o=(await Promise.all(r.map(async function(t){return{txHex:Buffer.from(await c.getTxHex({txid:t.txid}),"hex"),hash:t.txid,index:t.vout}}))).map(async function(t){return{hash:t.hash,index:t.index,nonWitnessUtxo:t.txHex}});break;case"segwit":o=d.map(t=>({hash:t.tx.txid,index:t.vout,witnessUtxo:{value:t.tx.vout[t.vout].value,script:Buffer.from(t.tx.vout[t.vout].scriptpubkey,"hex")}}));break;case"taproot":s?i=p.fromPrivateKey(Buffer.from(s),{network:u}):n&&(i=p.fromWIF(n,u));let t=e.tweakSigner(i,{network:u});o=d.map(r=>({hash:r.tx.txid,index:r.vout,witnessUtxo:{value:r.tx.vout[r.vout].value,script:Buffer.from(r.tx.vout[r.vout].scriptpubkey,"hex")},tapInternalKey:e.toXOnly(t.publicKey)}))}return o}catch(t){}},this.getTransactionSize=({input:t,output:e,addressType:r})=>{try{const a=148,s=34,n=32,i=67.75,o=31,c=43,u=57.25;let d,p=0,h=0,w=0,y=0;e.forEach(t=>{"P2TR"===t.outputType?w=t.count:"P2WPKH"===t.outputType?h=t.count:"P2TR"===t.outputType?w=t.count:"P2PKH"===t.outputType&&(p=t.count)});let f=0,l=0;switch(r){case"taproot":d="P2TR",f=u,l=108;break;case"segwit":d="P2WPKH",f=i,l=108;break;case"legacy":d="P2PKH",f=a}let m=this.getTxOverheadVBytes(d,t,e.length)+f*t+s*p+o*h+c*w+n*y;return m=Math.ceil(m),{txVBytes:m,txBytes:Math.ceil(this.getTxOverheadExtraRawBytes(d,t)+m+l*t*3/4),txWeight:Math.ceil(4*m)}}catch(t){throw new Error(t.message)}},this.getNetwork=t=>"mainnet"===t?s.bitcoin:"testnet"===t?s.testnet:void 0,this.getKeyPair=(t,e)=>{const r=t.slice(0,32),a=this.getNetwork(e);return p.fromPrivateKey(Buffer.from(r),{network:a})},this.mainnetAddressType=(t,e)=>{try{const r=t.trim();return/^1[0-9A-Za-z]{25,34}$/.test(r)?"P2PKH":/^3[0-9A-Za-z]{25,34}$/.test(r)?"P2SH":1==this.checkTaproot(r,e)?"P2TR":1==this.checkSegwit(r,e)?"P2WPKH":null}catch(t){throw new Error(t.message)}},this.testnetAddressType=t=>{try{const e=t.trim();if(/^m[0-9A-Za-z]{25,34}$/.test(e))return"P2PKH";if(/^2[0-9A-Za-z]{25,34}$/.test(e))return"P2SH";if(/^(tb1|[mn2])[a-zA-HJ-NP-Z0-9]{25,39}$/.test(e)){if(e.startsWith("tb1q"))return"P2WPKH";if(e.startsWith("tb1p"))return"P2TR"}return null}catch(t){throw new Error(t.message)}},this.checkTaproot=(t,e)=>{try{if("mainnet"===e&&t.startsWith("tb1q"))return!1;if("mainnet"===e&&t.startsWith("tb1p"))return!1;if(1===u.decode(t).words[0])return!0}catch(t){return!1}},this.checkSegwit=(t,e)=>{try{if("mainnet"===e&&t.startsWith("tb1q"))return!1;if("mainnet"===e&&t.startsWith("tb1p"))return!1;if(0===d.decode(t).words[0])return!0}catch(t){return!1}},this.getSizeOfScriptLengthElement=t=>t<75?1:t<=255?2:t<=65535?3:t<=4294967295?5:void alert("Size of redeem script is too large"),this.getSizeOfVarInt=t=>{if(t<253)return 1;if(t<65535)return 3;if(t<4294967295)return 5;if(t<0x10000000000000000)return 9;throw new Error("Invalid var int")},this.getTxOverheadVBytes=(t,e,r)=>{if("P2PKH"==t||"P2SH"==t)var a=0;else a=.5+e/4;return 4+this.getSizeOfVarInt(e)+this.getSizeOfVarInt(r)+4+a},this.getTxOverheadExtraRawBytes=(t,e)=>{if("P2PKH"==t||"P2SH"==t)var r=0;else r=.5+e/4;return 3*r}}tweakSigner(t,e){let r=t.privateKey;if(!r)throw new Error("Private key is required for tweaking signer!");3===t.publicKey[0]&&(r=i.privateNegate(r));const a=i.privateAdd(r,this.tapTweakHash(this.toXOnly(t.publicKey),e.tweakHash));if(!a)throw new Error("Invalid tweaked private key!");return p.fromPrivateKey(Buffer.from(a),{network:e.network})}tapTweakHash(t,e){return n.taggedHash("TapTweak",Buffer.concat(e?[t,e]:[t]))}toXOnly(t){return t.subarray(1,33)}}class w extends h{}var y;y=w,[h].forEach(t=>{Object.getOwnPropertyNames(t.prototype).forEach(e=>{Object.defineProperty(y.prototype,e,Object.getOwnPropertyDescriptor(t.prototype,e)||Object.create(null))})});export{w as default};
